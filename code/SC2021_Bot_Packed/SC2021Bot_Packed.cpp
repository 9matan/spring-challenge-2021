
#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC optimize("O3")
#pragma GCC optimize("inline")
#pragma GCC optimize("omit-frame-pointer")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("Ofast")
#endif 
#define _CRT_SECURE_NO_WARNINGS
#define _SCL_SECURE_NO_WARNINGS

constexpr int MAX_DAYS_COUNT = 33;constexpr int LAST_DAY_NUMBER = 23;constexpr int MAX_CELLS_COUNT = 37;constexpr int MAX_TREE_SIZE = 3;constexpr int COMPLETE_LIFECYCLE_PRICE = 4;constexpr int TREE_LEVEL_UPGRADE_BASE_PRICE[MAX_TREE_SIZE] = {1, 3, 7};

#include <chrono>
#include <ctime>
#include <string>
class CTimeProfiler{public:CTimeProfiler(char const* const name);~CTimeProfiler();private:std::string m_name;decltype(std::chrono::high_resolution_clock::now()) m_startTime;};
#ifndef DISABLE_PROFILE
#define PROFILE_TIME(name) CTimeProfiler timeProfiler(name);
#else
#define PROFILE_TIME(name)
#endif 

namespace sc2021{enum class ECommandType{Invalid = 0,Wait,Complete,Grow,Seed};struct SCommand{int m_cellIndex;int m_seedCellIndex;ECommandType m_commandType = ECommandType::Invalid;inline void Invalidate() { m_commandType = ECommandType::Invalid; }inline bool IsValid() const { return m_commandType != ECommandType::Invalid; }};
#define INVALID_COMMAND SCommand()
}
namespace sc2021{struct STurnOutputData{SCommand m_command;};}

#include <memory>
namespace sc2021{class CBotImpl;struct SInitInputData;struct STurnInputData;class CBot{public:CBot();~CBot();STurnOutputData FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData);STurnOutputData Update(STurnInputData const& turnInData);private:std::unique_ptr<CBotImpl> m_impl;};}
namespace sc2021{char const* ToString(SCommand const& cmd);SCommand CreateWaitCmd();SCommand CreateCompleteCmd(int const cellIndex);SCommand CreateGrowCmd(int const cellIndex);SCommand CreateSeedCmd(int const cellIndex, int const seedCellIndex);}
namespace sc2021{enum class EDirection{Right = 0,UpRight,UpLeft,Left,DownLeft,DownRight,Count};constexpr int DIRECTIONS_COUNT = (int)EDirection::Count;}

#include <algorithm>
#include <assert.h>
template<typename T, size_t TSize>class CVectorInPlace{public:CVectorInPlace() : m_nxtSlotIndex(0) {}CVectorInPlace(size_t const size) { resize(size); }CVectorInPlace(std::initializer_list<T> const& items){reserve(items.size());std::copy(items.begin(), items.end(), begin());m_nxtSlotIndex = items.size();}inline void push_back(T const& elem) { assert(m_nxtSlotIndex < TSize); m_data[m_nxtSlotIndex++] = elem; }template<typename ... TArgs>inline T& emplace_back(TArgs&& ... args) { m_data[m_nxtSlotIndex++] = std::move(T(std::forward<TArgs>(args)...)); return back(); }inline void pop_back() { m_nxtSlotIndex--; }inline T& back() { return m_data[m_nxtSlotIndex - 1]; }inline T& front() { return *m_data; }inline T const& back() const { return m_data[m_nxtSlotIndex - 1]; }inline T const& front() const { return *m_data; }inline size_t size() const { return m_nxtSlotIndex; }inline void resize(size_t const capacity) { m_nxtSlotIndex = capacity; }inline void reserve(size_t const capacity) { assert(capacity <= TSize); }inline size_t max_capacity() const { return TSize; }inline bool is_full() const { return m_nxtSlotIndex >= TSize; }void erase_swap(T* const iter){size_t const index = std::distance(m_data, iter);std::swap(m_data[index], m_data[m_nxtSlotIndex - 1]);pop_back();}inline bool empty() const { return m_nxtSlotIndex == 0; }inline void clear() { m_nxtSlotIndex = 0; }inline T* begin() { return m_data; }inline T* end() { return m_data + m_nxtSlotIndex; }inline T const* begin() const { return m_data; }inline T const* end() const { return m_data + m_nxtSlotIndex; }inline T& operator[](size_t const index) { assert(index < m_nxtSlotIndex); return m_data[index]; }inline T const& operator[](size_t const index) const { assert(index < m_nxtSlotIndex); return m_data[index]; }private:size_t m_nxtSlotIndex = 0;T m_data[TSize];};
#include <vector>
namespace sc2021{struct SInitCellInputData{int m_index;int m_richness;int m_neighs[DIRECTIONS_COUNT];};struct SInitInputData{CVectorInPlace<SInitCellInputData, MAX_CELLS_COUNT> m_cells;};struct STreeInputData{int m_cellIndex;int m_size;bool m_isMine;bool m_isDormant;};struct STurnInputData{int m_day;int m_nutriens;int m_mySun;int m_myScore;int m_oppSun;int m_oppScore;bool m_oppWaiting;CVectorInPlace<STreeInputData, MAX_CELLS_COUNT> m_trees;std::vector<std::string> m_possibleActions;};}

#include <iostream>
using namespace sc2021;using namespace std;void ReadInitInputData(SInitInputData& data){int numberOfCells;cin >> numberOfCells; cin.ignore();cerr << numberOfCells << "\n";data.m_cells.resize(numberOfCells);for (auto& cell : data.m_cells){cin >> cell.m_index>> cell.m_richness;cerr << cell.m_index << " "<< cell.m_richness;for (auto& neigh : cell.m_neighs){cin >> neigh;cerr << " " << neigh;}cin.ignore();cerr << "\n";}}void ReadTurnInputData(STurnInputData& data){cin >> data.m_day; cin.ignore();cin >> data.m_nutriens; cin.ignore();cin >> data.m_mySun>> data.m_myScore; cin.ignore();cin >> data.m_oppSun>> data.m_oppScore>> data.m_oppWaiting; cin.ignore();int numberOfTrees;cin >> numberOfTrees; cin.ignore();data.m_trees.resize(numberOfTrees);for (auto& tree : data.m_trees){cin >> tree.m_cellIndex;cin >> tree.m_size;cin >> tree.m_isMine;cin >> tree.m_isDormant; cin.ignore();}int numberOfPossibleActions;cin >> numberOfPossibleActions; cin.ignore();data.m_possibleActions.resize(numberOfPossibleActions);for (auto& action : data.m_possibleActions){getline(cin, action);}}void WriteTurnOutputData(STurnOutputData const& data){cout << ToString(data.m_command) << "\n";fflush(stderr);fflush(stdout);}int main(){SInitInputData initInputData;STurnInputData turnInputData;STurnOutputData turnOutputData;CBot bot;ReadInitInputData(initInputData);ReadTurnInputData(turnInputData);{PROFILE_TIME("First update");turnOutputData = bot.FirstUpdate(initInputData, turnInputData);}WriteTurnOutputData(turnOutputData);while (true){ReadTurnInputData(turnInputData);{PROFILE_TIME("Update");turnOutputData = bot.Update(turnInputData);}WriteTurnOutputData(turnOutputData);}return 0;}

#define _CRT_SECURE_NO_WARNINGS
#include <array>
#include <cstring>
#include <queue>
#include <unordered_map>
namespace sc2021{char const* ToString(SCommand const& cmd){static char buff[256];switch (cmd.m_commandType){case ECommandType::Invalid:sprintf(buff, "Invalid");break;case ECommandType::Wait:sprintf(buff, "WAIT");break;case ECommandType::Complete:sprintf(buff, "COMPLETE %i", cmd.m_cellIndex);break;case ECommandType::Grow:sprintf(buff, "GROW %i", cmd.m_cellIndex);break;case ECommandType::Seed:sprintf(buff, "SEED %i %i", cmd.m_cellIndex, cmd.m_seedCellIndex);break;default:assert(false);}return buff;}SCommand CreateWaitCmd(){SCommand cmd;cmd.m_commandType = ECommandType::Wait;return cmd;}SCommand CreateCompleteCmd(int const cellIndex){SCommand cmd;cmd.m_cellIndex = cellIndex;cmd.m_commandType = ECommandType::Complete;return cmd;}SCommand CreateGrowCmd(int const cellIndex){SCommand cmd;cmd.m_cellIndex = cellIndex;cmd.m_commandType = ECommandType::Grow;return cmd;}SCommand CreateSeedCmd(int const cellIndex, int const seedCellIndex){SCommand cmd;cmd.m_cellIndex = cellIndex;cmd.m_seedCellIndex = seedCellIndex;cmd.m_commandType = ECommandType::Seed;return cmd;}}
namespace sc2021{struct STreeEntity{int m_size = -1;bool m_isMine;bool m_isDormant;inline void Invalidate() { m_size = -1; }inline bool IsValid() const { return m_size != -1; }};
#define INVALID_TREE_ENTITY STreeEntity()
}
namespace sc2021{struct STreeEntity;struct SCellEntity{STreeEntity m_tree;int m_index;int m_richness;SCellEntity* m_neigh[DIRECTIONS_COUNT] = { 0 };inline bool HasMyTree_Dormant(bool const isDormant) const { return HasMyTree() && m_tree.m_isDormant == isDormant; }inline bool HasMyTree() const { return m_tree.IsValid() && m_tree.m_isMine; }inline bool HasTree() const { return m_tree.IsValid(); }};}
namespace sc2021{class CMap{public:using CellPredicate = bool(*)(SCellEntity const&);using Cells = CVectorInPlace<SCellEntity*, MAX_CELLS_COUNT>;public:void GetCells(Cells& cells, CellPredicate predicate);void GetCellsInRadius(Cells& cells, int const cellIndex, int const radius);public:inline SCellEntity* begin() { return std::begin(m_cells); }inline SCellEntity* end() { return std::end(m_cells); }inline SCellEntity& operator[](size_t const index) { return m_cells[index]; }inline SCellEntity const* begin() const { return std::begin(m_cells); }inline SCellEntity const* end() const { return std::end(m_cells); }inline SCellEntity const& operator[](size_t const index) const { return m_cells[index]; }private:SCellEntity m_cells[MAX_CELLS_COUNT];};}
constexpr int MAX_TURNS_PER_DAY = 16;namespace sc2021{enum class ETurnStrategyType{Invalid = 0,CompleteLifeCycle,IncreaseIncome,UpgradeToLargeTree,SeedNewTree};struct STurnStrategy{ETurnStrategyType m_strategyType = ETurnStrategyType::Invalid;bool m_repeat;inline void Invalidate() { m_strategyType = ETurnStrategyType::Invalid; }inline bool IsValid() const { return m_strategyType == ETurnStrategyType::Invalid; }};
#define INVALID_TURN_STRATEGY STurnStrategy()
struct SDayStrategy{CVectorInPlace<STurnStrategy, MAX_TURNS_PER_DAY> m_turnStrategies;bool m_isValid = false;inline void Invalidate() { m_turnStrategies.clear(); m_isValid = false; }inline bool IsValid() const { return !m_turnStrategies.empty() || m_isValid; }inline void Validate() { m_isValid = true; }};
#define INVALID_DAY_STRATEGY SDayStrategy()
}
namespace sc2021{class CBotImpl{public:STurnOutputData FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData);STurnOutputData Update(STurnInputData const& turnInData);private:STurnInputData m_turnData;std::unordered_map<int, SDayStrategy> m_predefinedDayStrategies;SDayStrategy m_defaultDayStrategy;SDayStrategy m_currentDayStrategy;CMap m_map;int m_myTreesCntBySize[MAX_TREE_SIZE + 1];private:void InitMap(SInitInputData const& initData);void UpdateTrees(STurnInputData const& turnInData);SDayStrategy CalculateDayStrategy();SCommand FindTurn();SCommand FindTurnByStrategy(STurnStrategy const& turnStrategy);SCommand FindTurn_CompleteLifeCycle(STurnStrategy const& turnStrategy);SCommand FindTurn_IncreaseIncome(STurnStrategy const& turnStrategy);SCommand FindTurn_UpgradeToLargeTree(STurnStrategy const& turnStrategy);SCommand FindTurn_SeedNewTree(STurnStrategy const& turnStrategy);void OnNewDay(STurnInputData const& newData);private:inline int GetUpgradePrice(int const treeSize) const{assert("INVALID tree size" && treeSize >= 0 && treeSize < MAX_TREE_SIZE);return TREE_LEVEL_UPGRADE_BASE_PRICE[treeSize] + m_myTreesCntBySize[treeSize + 1];}inline int GetSeedPrice() const { return m_myTreesCntBySize[0];}inline int GetMySun() const { return m_turnData.m_mySun; }inline int GetMyScore() const { return m_turnData.m_myScore; }};}
using namespace std;namespace sc2021{CBot::CBot() : m_impl(make_unique<CBotImpl>()) {}CBot::~CBot() {}STurnOutputData CBot::FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData){return m_impl->FirstUpdate(initInData, turnInData);}STurnOutputData CBot::Update(STurnInputData const& turnInData){return m_impl->Update(turnInData);}}
unsigned int UpdateRandomSeed();unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal);template<typename TIter>TIter GetRandomItem(TIter first, TIter last){size_t const rangeSize = static_cast<size_t>(last - first);return first + GetRandomUInt(0, static_cast<unsigned int>(rangeSize));}template<typename TEnum>TEnum GetRandomEnumValue(){return static_cast<TEnum>(GetRandomUInt(0, static_cast<unsigned int>(TEnum::Count)));}
namespace sc2021{char const* ToString(STurnStrategy const& turnStrategy);STurnStrategy CreateCompleteLifeCycleTS(bool const repeat = false);STurnStrategy CreateIncreaseIncomeTS(bool const repeat = false);STurnStrategy CreateUpgradeToLargeTreeTS(bool const repeat = false);STurnStrategy CreateSeedNewTreeTS(bool const repeat = false);}
using namespace std;namespace sc2021{STurnOutputData CBotImpl::FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData){int const seed = UpdateRandomSeed();cerr << "Bot seed: " << seed << "\n";InitMap(initInData);{int nxtDay = 0;for (int i = 0; i < 3; ++i){{auto& day = m_predefinedDayStrategies[nxtDay++];day.m_turnStrategies.push_back(CreateSeedNewTreeTS());day.m_turnStrategies.push_back(CreateSeedNewTreeTS());day.m_turnStrategies.push_back(CreateIncreaseIncomeTS(true));}for (int j = 0; j < 4; ++j){auto& day = m_predefinedDayStrategies[nxtDay++];day.m_turnStrategies.push_back(CreateIncreaseIncomeTS(true));}{auto& day = m_predefinedDayStrategies[nxtDay++];day.m_turnStrategies.push_back(CreateCompleteLifeCycleTS());day.m_turnStrategies.push_back(CreateIncreaseIncomeTS(true));}}{auto& day = m_predefinedDayStrategies[nxtDay++];day.m_turnStrategies.push_back(CreateSeedNewTreeTS());day.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));}{auto& preLastDay = m_predefinedDayStrategies[LAST_DAY_NUMBER - 1];preLastDay.m_turnStrategies.push_back(CreateCompleteLifeCycleTS(true));preLastDay.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));}{auto& lastDay = m_predefinedDayStrategies[LAST_DAY_NUMBER];lastDay.m_turnStrategies.emplace_back(CreateCompleteLifeCycleTS(true));}m_defaultDayStrategy.m_turnStrategies.push_back(CreateCompleteLifeCycleTS());m_defaultDayStrategy.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));}m_turnData.m_day = -1;return Update(turnInData);}void CBotImpl::InitMap(SInitInputData const& initInData){for (auto const& cellData : initInData.m_cells){auto& cell = m_map[cellData.m_index];cell.m_index = cellData.m_index;cell.m_richness = cellData.m_richness;cell.m_tree.Invalidate();int direction = 0;for (int neighIndex : cellData.m_neighs){if (neighIndex >= 0){cell.m_neigh[direction] = m_map.begin() + neighIndex;}++direction;}}}STurnOutputData CBotImpl::Update(STurnInputData const& turnInData){UpdateTrees(turnInData);if (turnInData.m_day != m_turnData.m_day){OnNewDay(turnInData);}m_turnData = turnInData;STurnOutputData outputData;outputData.m_command = FindTurn();return outputData;}void CBotImpl::UpdateTrees(STurnInputData const& turnInData){memset(m_myTreesCntBySize, 0, sizeof(m_myTreesCntBySize));CVectorInPlace<int, MAX_CELLS_COUNT> indicesWithTree;for (auto const& treeData : turnInData.m_trees){indicesWithTree.push_back(treeData.m_cellIndex);auto& cell = m_map[treeData.m_cellIndex];cell.m_tree.m_size = treeData.m_size;cell.m_tree.m_isMine = treeData.m_isMine;cell.m_tree.m_isDormant = treeData.m_isDormant;if (treeData.m_isMine){++m_myTreesCntBySize[treeData.m_size];}}for (auto& cell : m_map){if (find(indicesWithTree.begin(), indicesWithTree.end(), cell.m_index) == indicesWithTree.end()){cell.m_tree.Invalidate();}}}void CBotImpl::OnNewDay(STurnInputData const& newData){if (m_predefinedDayStrategies.find(newData.m_day) == m_predefinedDayStrategies.end()){m_currentDayStrategy = CalculateDayStrategy();if (!m_currentDayStrategy.IsValid()){m_currentDayStrategy = m_defaultDayStrategy;}}else{m_currentDayStrategy = m_predefinedDayStrategies[newData.m_day];}reverse(m_currentDayStrategy.m_turnStrategies.begin(), m_currentDayStrategy.m_turnStrategies.end());}SDayStrategy CBotImpl::CalculateDayStrategy(){return INVALID_DAY_STRATEGY;}SCommand CBotImpl::FindTurn(){auto& turns = m_currentDayStrategy.m_turnStrategies;while (!turns.empty()){auto const& turn = turns.back();SCommand const cmd = FindTurnByStrategy(turn);if (!cmd.IsValid()){cerr << ToString(turn) << " -> Fail\n";turns.pop_back();}else{cerr << ToString(turn) << " -> Success\n";if (!turn.m_repeat){turns.pop_back();}return cmd;}}return CreateWaitCmd();}SCommand CBotImpl::FindTurnByStrategy(STurnStrategy const& turnStrategy){switch (turnStrategy.m_strategyType){case ETurnStrategyType::CompleteLifeCycle:return FindTurn_CompleteLifeCycle(turnStrategy);case ETurnStrategyType::IncreaseIncome:return FindTurn_IncreaseIncome(turnStrategy);case ETurnStrategyType::UpgradeToLargeTree:return FindTurn_UpgradeToLargeTree(turnStrategy);case ETurnStrategyType::SeedNewTree:return FindTurn_SeedNewTree(turnStrategy);default:assert(!"Unhandled ETurnStrategyType");}assert(false);return INVALID_COMMAND;}SCommand CBotImpl::FindTurn_CompleteLifeCycle(STurnStrategy const& turnStrategy){if (m_turnData.m_mySun < COMPLETE_LIFECYCLE_PRICE){return INVALID_COMMAND;}SCellEntity const* curCell = nullptr;for (auto const& cell : m_map){if (cell.HasMyTree_Dormant(false) && cell.m_tree.m_size == MAX_TREE_SIZE){if (curCell == nullptr || curCell->m_richness < cell.m_richness){curCell = &cell;}}}if (!curCell || (curCell->m_richness <= 1 && m_turnData.m_nutriens == 0)){return INVALID_COMMAND;}return CreateCompleteCmd(curCell->m_index);}SCommand CBotImpl::FindTurn_IncreaseIncome(STurnStrategy const& turnStrategy){SCellEntity const* curCell = nullptr;int curUpgradePrice = -1;for (auto const& cell : m_map){if (cell.HasMyTree_Dormant(false) && cell.m_tree.m_size < MAX_TREE_SIZE){int const price = GetUpgradePrice(cell.m_tree.m_size);if (curUpgradePrice == -1|| price < curUpgradePrice|| price == curUpgradePrice && curCell->m_richness < cell.m_richness){curUpgradePrice = price;curCell = &cell;}}}if (curUpgradePrice == -1 || GetMySun() < curUpgradePrice){return INVALID_COMMAND;}return CreateGrowCmd(curCell->m_index);}SCommand CBotImpl::FindTurn_UpgradeToLargeTree(STurnStrategy const& turnStrategy){SCellEntity const* curCell = nullptr;for (auto const& cell : m_map){if (cell.HasMyTree_Dormant(false) && cell.m_tree.m_size < MAX_TREE_SIZE){if (curCell == nullptr|| curCell->m_tree.m_size < cell.m_tree.m_size|| (curCell->m_tree.m_size == cell.m_tree.m_size && curCell->m_richness < cell.m_richness)){curCell = &cell;}}}if (curCell == nullptr || GetMySun() < GetUpgradePrice(curCell->m_tree.m_size)){return INVALID_COMMAND;}return CreateGrowCmd(curCell->m_index);}SCommand CBotImpl::FindTurn_SeedNewTree(STurnStrategy const& turnStrategy){if (GetMySun() < GetSeedPrice()){return INVALID_COMMAND;}SCellEntity const* curCell = nullptr;SCellEntity const* curSeedCell = nullptr;CMap::Cells neighCells;for (auto const& cell : m_map){if (cell.HasMyTree_Dormant(false) && cell.m_tree.m_size > 0){m_map.GetCellsInRadius(neighCells, cell.m_index, cell.m_tree.m_size);for (auto const neighCell : neighCells){if (neighCell->m_richness == 0) continue;if (neighCell->HasTree()) continue;if (curSeedCell == nullptr|| (curSeedCell->m_richness < neighCell->m_richness)){curCell = &cell;curSeedCell = neighCell;}}}}if (!curCell){return INVALID_COMMAND;}assert(curCell && curSeedCell);return CreateSeedCmd(curCell->m_index, curSeedCell->m_index);}}
namespace sc2021{void CMap::GetCells(Cells& cells, CellPredicate predicate){cells.clear();for (auto& cell : m_cells){if (predicate(cell)){cells.push_back(&cell);}}}void CMap::GetCellsInRadius(Cells& cells, int const cellIndex, int const radius){assert(cellIndex >= 0 && cellIndex < MAX_CELLS_COUNT);cells.clear();bool added[MAX_CELLS_COUNT];memset(added, 0, sizeof(added));added[cellIndex] = true;std::queue<std::pair<int, int>> q;q.push(std::make_pair(cellIndex, 0));while (!q.empty()){auto const cur = q.front();int const index = cur.first;int const distance = cur.second;auto& cell = m_cells[index];q.pop();cells.push_back(&cell);if (distance < radius){for (auto& neigh : cell.m_neigh){if (!neigh) continue;if (added[neigh->m_index]) continue;added[neigh->m_index] = true;q.push(std::make_pair(neigh->m_index, distance + 1));}}}}}
namespace sc2021{char const* ToString(STurnStrategy const& turnStrategy){static char buff[256];int curPos = 0;if (!turnStrategy.IsValid()){switch (turnStrategy.m_strategyType){case ETurnStrategyType::CompleteLifeCycle:curPos = sprintf(buff, "CompleteLifeCycle");break;case ETurnStrategyType::IncreaseIncome:curPos = sprintf(buff, "IncreaseIncome");break;case ETurnStrategyType::UpgradeToLargeTree:curPos = sprintf(buff, "UpgradeToLargeTree");break;case ETurnStrategyType::SeedNewTree:curPos = sprintf(buff, "SeedNewTree");break;default:assert(!"Unhandled ETurnStrategyType");}if (turnStrategy.m_repeat){curPos = sprintf(buff + curPos, " repetitive");}}else{sprintf(buff, "Invalid");}return buff;}STurnStrategy CreateCompleteLifeCycleTS(bool const repeat){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::CompleteLifeCycle;strategy.m_repeat = repeat;return strategy;}STurnStrategy CreateIncreaseIncomeTS(bool const repeat){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::IncreaseIncome;strategy.m_repeat = repeat;return strategy;}STurnStrategy CreateUpgradeToLargeTreeTS(bool const repeat){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::UpgradeToLargeTree;strategy.m_repeat = repeat;return strategy;}STurnStrategy CreateSeedNewTreeTS(bool const repeat){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::SeedNewTree;strategy.m_repeat = repeat;return strategy;}}
#include <random>
#include <time.h>
unsigned int UpdateRandomSeed(){unsigned int const seed = (unsigned int)time(nullptr);srand(seed);return seed;}unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal){assert(minVal < maxVal);unsigned int const range = maxVal - minVal;return rand() % range + minVal;}
using namespace std;CTimeProfiler::CTimeProfiler(char const* const name): m_name(name), m_startTime(chrono::high_resolution_clock::now()){}CTimeProfiler::~CTimeProfiler(){auto const end = chrono::high_resolution_clock::now();double const executionTime = (double)chrono::duration_cast<chrono::nanoseconds>(end - m_startTime).count();cerr.precision(3);cerr << m_name << ": " << executionTime / 1000000.0 << fixed << " ms" << endl;}
