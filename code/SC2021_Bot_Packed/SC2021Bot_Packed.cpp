
#if defined(__GNUC__) || defined(__GNUG__)
#pragma GCC optimize("O3")
#pragma GCC optimize("inline")
#pragma GCC optimize("omit-frame-pointer")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("Ofast")
#endif 
#define _CRT_SECURE_NO_WARNINGS
#define _SCL_SECURE_NO_WARNINGS

constexpr int MAX_DAYS_COUNT = 32;constexpr int MAX_NEIGHS_COUNT = 6;constexpr int MAX_CELLS_COUNT = 37;constexpr int MAX_TREE_SIZE = 3;constexpr int COMPLETE_LIFECYCLE_PRICE = 4;constexpr int TREE_LEVEL_UPGRADE_BASE_PRICE[MAX_TREE_SIZE] = {0, 3, 7};

#include <chrono>
#include <ctime>
#include <string>
class CTimeProfiler{public:CTimeProfiler(char const* const name);~CTimeProfiler();private:std::string m_name;decltype(std::chrono::high_resolution_clock::now()) m_startTime;};
#ifndef DISABLE_PROFILE
#define PROFILE_TIME(name) CTimeProfiler timeProfiler(name);
#else
#define PROFILE_TIME(name)
#endif 

namespace sc2021{enum class ECommandType{Invalid = 0,Wait,Complete,Grow};struct SCommand{int m_cellIndex;ECommandType m_commandType = ECommandType::Invalid;inline void Invalidate() { m_commandType = ECommandType::Invalid; }inline bool IsValid() const { return m_commandType != ECommandType::Invalid; }};inline SCommand CreateWaitCmd(){SCommand cmd;cmd.m_commandType = ECommandType::Wait;return cmd;}inline SCommand CreateCompleteCmd(int const cellIndex){SCommand cmd;cmd.m_cellIndex = cellIndex;cmd.m_commandType = ECommandType::Complete;return cmd;}inline SCommand CreateGrowCmd(int const cellIndex){SCommand cmd;cmd.m_cellIndex = cellIndex;cmd.m_commandType = ECommandType::Grow;return cmd;}}
namespace sc2021{struct STurnOutputData{SCommand m_command;};}

#include <memory>
namespace sc2021{class CBotImpl;struct SInitInputData;struct STurnInputData;class CBot{public:CBot();~CBot();STurnOutputData FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData);STurnOutputData Update(STurnInputData const& turnInData);private:std::unique_ptr<CBotImpl> m_impl;};}
namespace sc2021{struct SCommand;std::string ToString(SCommand const& cmd);}

#include <algorithm>
#include <assert.h>
template<typename T, size_t TSize>class CVectorInPlace{public:CVectorInPlace() : m_nxtSlotIndex(0) {}CVectorInPlace(size_t const size) { resize(size); }CVectorInPlace(std::initializer_list<T> const& items){reserve(items.size());std::copy(items.begin(), items.end(), begin());m_nxtSlotIndex = items.size();}inline void push_back(T const& elem) { assert(m_nxtSlotIndex < TSize); m_data[m_nxtSlotIndex++] = elem; }template<typename ... TArgs>inline T& emplace_back(TArgs&& ... args) { m_data[m_nxtSlotIndex++] = std::move(T(std::forward<TArgs>(args)...)); return back(); }inline void pop_back() { m_nxtSlotIndex--; }inline T& back() { return m_data[m_nxtSlotIndex - 1]; }inline T& front() { return *m_data; }inline T const& back() const { return m_data[m_nxtSlotIndex - 1]; }inline T const& front() const { return *m_data; }inline size_t size() const { return m_nxtSlotIndex; }inline void resize(size_t const capacity) { m_nxtSlotIndex = capacity; }inline void reserve(size_t const capacity) { assert(capacity <= TSize); }inline size_t max_capacity() const { return TSize; }inline bool is_full() const { return m_nxtSlotIndex >= TSize; }void erase_swap(T* const iter){size_t const index = std::distance(m_data, iter);std::swap(m_data[index], m_data[m_nxtSlotIndex - 1]);pop_back();}inline bool empty() const { return m_nxtSlotIndex == 0; }inline void clear() { m_nxtSlotIndex = 0; }inline T* begin() { return m_data; }inline T* end() { return m_data + m_nxtSlotIndex; }inline T const* begin() const { return m_data; }inline T const* end() const { return m_data + m_nxtSlotIndex; }inline T& operator[](size_t const index) { assert(index < m_nxtSlotIndex); return m_data[index]; }inline T const& operator[](size_t const index) const { assert(index < m_nxtSlotIndex); return m_data[index]; }private:size_t m_nxtSlotIndex = 0;T m_data[TSize];};
#include <vector>
namespace sc2021{struct SInitCellInputData{int m_index;int m_richness;CVectorInPlace<int, MAX_NEIGHS_COUNT> m_neighs;};struct SInitInputData{CVectorInPlace<SInitCellInputData, MAX_CELLS_COUNT> m_cells;};struct STreeInputData{int m_cellIndex;int m_size;bool m_isMine;bool m_isDormant;};struct STurnInputData{int m_day;int m_nutriens;int m_mySun;int m_myScore;int m_oppSun;int m_oppScore;bool m_oppWaiting;CVectorInPlace<STreeInputData, MAX_CELLS_COUNT> m_trees;std::vector<std::string> m_possibleActions;};}

#include <iostream>
using namespace sc2021;using namespace std;void ReadInitInputData(SInitInputData& data){int numberOfCells;cin >> numberOfCells; cin.ignore();cerr << numberOfCells << "\n";data.m_cells.resize(numberOfCells);for (auto& cell : data.m_cells){cin >> cell.m_index>> cell.m_richness;cerr << cell.m_index << " "<< cell.m_richness;cell.m_neighs.resize(MAX_NEIGHS_COUNT);for (auto& neigh : cell.m_neighs){cin >> neigh;cerr << " " << neigh;}cin.ignore();cerr << "\n";}}void ReadTurnInputData(STurnInputData& data){cin >> data.m_day; cin.ignore();cin >> data.m_nutriens; cin.ignore();cin >> data.m_mySun>> data.m_myScore; cin.ignore();cin >> data.m_oppSun>> data.m_oppScore>> data.m_oppWaiting; cin.ignore();int numberOfTrees;cin >> numberOfTrees; cin.ignore();data.m_trees.resize(numberOfTrees);for (auto& tree : data.m_trees){cin >> tree.m_cellIndex;cin >> tree.m_size;cin >> tree.m_isMine;cin >> tree.m_isDormant; cin.ignore();}int numberOfPossibleActions;cin >> numberOfPossibleActions; cin.ignore();data.m_possibleActions.resize(numberOfPossibleActions);for (auto& action : data.m_possibleActions){getline(cin, action);}}void WriteTurnOutputData(STurnOutputData const& data){cout << ToString(data.m_command) << "\n";fflush(stderr);fflush(stdout);}int main(){SInitInputData initInputData;STurnInputData turnInputData;STurnOutputData turnOutputData;CBot bot;ReadInitInputData(initInputData);ReadTurnInputData(turnInputData);{PROFILE_TIME("First update");turnOutputData = bot.FirstUpdate(initInputData, turnInputData);}WriteTurnOutputData(turnOutputData);while (true){ReadTurnInputData(turnInputData);{PROFILE_TIME("Update");turnOutputData = bot.Update(turnInputData);}WriteTurnOutputData(turnOutputData);}return 0;}

#define _CRT_SECURE_NO_WARNINGS

#include <array>
#include <cstring>
#include <queue>

namespace sc2021{std::string ToString(SCommand const& cmd){char buff[256];switch (cmd.m_commandType){case ECommandType::Wait:sprintf(buff, "WAIT");break;case ECommandType::Complete:sprintf(buff, "COMPLETE %i", cmd.m_cellIndex);break;case ECommandType::Grow:sprintf(buff, "GROW %i", cmd.m_cellIndex);break;default:assert(false);}return buff;}}
namespace sc2021{struct STreeEntity{int m_size;bool m_isMine;bool m_isDormant;inline void Invalidate() { m_size = -1; }inline bool IsValid() const { return m_size != -1; }};}
namespace sc2021{struct STreeEntity;struct SCellEntity{STreeEntity m_tree;int m_index;int m_richness;inline bool HasMyTree_Dormant(bool const isDormant) const { return HasMyTree() && m_tree.m_isDormant == isDormant; }inline bool HasMyTree() const { return m_tree.IsValid() && m_tree.m_isMine; }};}
constexpr int MAX_TURNS_PER_DAY = 16;namespace sc2021{enum class EDayStrategyType{Default = 0,Predefined};enum class ETurnStrategyType{CompleteLifeCycle = 0,IncreaseIncome = 1,UpgradeToLargeTree = 2};struct STurnStrategy{ETurnStrategyType m_strategyType;bool m_repeat;};struct SDayStrategy{EDayStrategyType m_strategyType;CVectorInPlace<STurnStrategy, MAX_TURNS_PER_DAY> m_turnStrategies;};inline STurnStrategy CreateCompleteLifeCycleTS(bool const repeat = false){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::CompleteLifeCycle;strategy.m_repeat = repeat;return strategy;}inline STurnStrategy CreateIncreaseIncomeTS(bool const repeat = false){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::IncreaseIncome;strategy.m_repeat = repeat;return strategy;}inline STurnStrategy CreateUpgradeToLargeTreeTS(bool const repeat = false){STurnStrategy strategy;strategy.m_strategyType = ETurnStrategyType::UpgradeToLargeTree;strategy.m_repeat = repeat;return strategy;}}
namespace sc2021{class CBotImpl{public:STurnOutputData FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData);STurnOutputData Update(STurnInputData const& turnInData);private:STurnInputData m_turnData;CVectorInPlace<SDayStrategy, MAX_DAYS_COUNT> m_dayStrategies;SDayStrategy m_currentDayStrategy;CVectorInPlace<SCellEntity, MAX_CELLS_COUNT> m_cells;int m_myTreesCntBySize[MAX_TREE_SIZE + 1];private:void InitCells(SInitInputData const& initData);void UpdateTrees(STurnInputData const& turnInData);SCommand FindTurn();SCommand FindTurnByStrategy(STurnStrategy const turnStrategy);SCommand FindTurn_CompleteLifeCycle();SCommand FindTurn_IncreaseIncome();SCommand FindTurn_UpgradeToLargeTree();void OnNewDay(STurnInputData const& newData);private:inline int GetUpgradePrice(int const treeSize) const{assert("INVALID tree size" && treeSize > 0 && treeSize < MAX_TREE_SIZE);return TREE_LEVEL_UPGRADE_BASE_PRICE[treeSize] + m_myTreesCntBySize[treeSize + 1];}inline int GetMySun() const { return m_turnData.m_mySun; }inline int GetMyScore() const { return m_turnData.m_myScore; }};}
using namespace std;namespace sc2021{CBot::CBot() : m_impl(make_unique<CBotImpl>()) {}CBot::~CBot() {}STurnOutputData CBot::FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData){return m_impl->FirstUpdate(initInData, turnInData);}STurnOutputData CBot::Update(STurnInputData const& turnInData){return m_impl->Update(turnInData);}}
unsigned int UpdateRandomSeed();unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal);template<typename TIter>TIter GetRandomItem(TIter first, TIter last){size_t const rangeSize = static_cast<size_t>(last - first);return first + GetRandomUInt(0, static_cast<unsigned int>(rangeSize));}template<typename TEnum>TEnum GetRandomEnumValue(){return static_cast<TEnum>(GetRandomUInt(0, static_cast<unsigned int>(TEnum::Count)));}
using namespace std;namespace sc2021{STurnOutputData CBotImpl::FirstUpdate(SInitInputData const& initInData, STurnInputData const& turnInData){int const seed = UpdateRandomSeed();cerr << "Bot seed: " << seed << "\n";InitCells(initInData);auto& day0 = m_dayStrategies.emplace_back();day0.m_strategyType = EDayStrategyType::Predefined;day0.m_turnStrategies.push_back(CreateIncreaseIncomeTS(true));auto& day1 = m_dayStrategies.emplace_back();day1.m_strategyType = EDayStrategyType::Predefined;day1.m_turnStrategies.push_back(CreateIncreaseIncomeTS(true));auto& day2 = m_dayStrategies.emplace_back();day2.m_strategyType = EDayStrategyType::Predefined;day2.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));auto& day3 = m_dayStrategies.emplace_back();day3.m_strategyType = EDayStrategyType::Predefined;day3.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));auto& day4 = m_dayStrategies.emplace_back();day4.m_strategyType = EDayStrategyType::Predefined;auto& day5 = m_dayStrategies.emplace_back();day5.m_strategyType = EDayStrategyType::Predefined;day5.m_turnStrategies.push_back(CreateCompleteLifeCycleTS(true));auto& defaultDay = m_dayStrategies.emplace_back();defaultDay.m_strategyType = EDayStrategyType::Predefined;defaultDay.m_turnStrategies.push_back(CreateCompleteLifeCycleTS(true));defaultDay.m_turnStrategies.push_back(CreateUpgradeToLargeTreeTS(true));m_turnData.m_day = -1;return Update(turnInData);}void CBotImpl::InitCells(SInitInputData const& initInData){m_cells.resize(initInData.m_cells.size());for (auto const& cellData : initInData.m_cells){auto& cell = m_cells[cellData.m_index];cell.m_index = cellData.m_index;cell.m_richness = cellData.m_richness;cell.m_tree.Invalidate();}}STurnOutputData CBotImpl::Update(STurnInputData const& turnInData){UpdateTrees(turnInData);if (turnInData.m_day != m_turnData.m_day){OnNewDay(turnInData);}m_turnData = turnInData;STurnOutputData outputData;outputData.m_command = FindTurn();return outputData;}void CBotImpl::UpdateTrees(STurnInputData const& turnInData){memset(m_myTreesCntBySize, 0, sizeof(m_myTreesCntBySize));CVectorInPlace<int, MAX_CELLS_COUNT> indicesWithTree;for (auto const& treeData : turnInData.m_trees){indicesWithTree.push_back(treeData.m_cellIndex);auto& cell = m_cells[treeData.m_cellIndex];cell.m_tree.m_size = treeData.m_size;cell.m_tree.m_isMine = treeData.m_isMine;cell.m_tree.m_isDormant = treeData.m_isDormant;if (treeData.m_isMine){++m_myTreesCntBySize[treeData.m_size];}}for (auto& cell : m_cells){if (find(indicesWithTree.begin(), indicesWithTree.end(), cell.m_index) == indicesWithTree.end()){cell.m_tree.Invalidate();}}}void CBotImpl::OnNewDay(STurnInputData const& newData){if (newData.m_day > m_dayStrategies.size()){m_currentDayStrategy = m_dayStrategies.back();}else{m_currentDayStrategy = m_dayStrategies[newData.m_day];}reverse(m_currentDayStrategy.m_turnStrategies.begin(), m_currentDayStrategy.m_turnStrategies.end());}SCommand CBotImpl::FindTurn(){auto& turns = m_currentDayStrategy.m_turnStrategies;while (!turns.empty()){auto const& turn = turns.back();SCommand const cmd = FindTurnByStrategy(turn);if (!cmd.IsValid()){turns.pop_back();}else{if (!turn.m_repeat){turns.pop_back();}return cmd;}}return CreateWaitCmd();}SCommand CBotImpl::FindTurnByStrategy(STurnStrategy const turnStrategy){switch (turnStrategy.m_strategyType){case ETurnStrategyType::CompleteLifeCycle:return FindTurn_CompleteLifeCycle();case ETurnStrategyType::IncreaseIncome:return FindTurn_IncreaseIncome();case ETurnStrategyType::UpgradeToLargeTree:return FindTurn_UpgradeToLargeTree();default:assert(!"Unhandled ETurnStrategyType");}assert(false);return SCommand();}SCommand CBotImpl::FindTurn_CompleteLifeCycle(){cerr << "FindTurn_CompleteLifeCycle\n";if (m_turnData.m_mySun < COMPLETE_LIFECYCLE_PRICE){return SCommand();}SCellEntity const* curCell = nullptr;for (auto const& cell : m_cells){if (cell.HasMyTree_Dormant(false) && cell.m_tree.m_size == MAX_TREE_SIZE){if (curCell == nullptr || curCell->m_richness < cell.m_richness){curCell = &cell;}}}if (!curCell || (curCell->m_richness <= 1 && m_turnData.m_nutriens == 0)){return SCommand();}return CreateCompleteCmd(curCell->m_index);}SCommand CBotImpl::FindTurn_IncreaseIncome(){cerr << "FindTurn_IncreaseIncome\n";SCellEntity const* curCell = nullptr;int curUpgradePrice = -1;for (auto const& cell : m_cells){if (cell.HasMyTree_Dormant(false) && (cell.m_tree.m_size != MAX_TREE_SIZE && cell.m_tree.m_size != 0)){int const price = GetUpgradePrice(cell.m_tree.m_size);if (curUpgradePrice == -1|| price < curUpgradePrice|| price == curUpgradePrice && curCell->m_richness < cell.m_richness){curUpgradePrice = price;curCell = &cell;}}}if (curUpgradePrice == -1 || GetMySun() < curUpgradePrice){return SCommand();}return CreateGrowCmd(curCell->m_index);}SCommand CBotImpl::FindTurn_UpgradeToLargeTree(){cerr << "FindTurn_UpgradeToLargeTree\n";SCellEntity const* curCell = nullptr;for (auto const& cell : m_cells){if (cell.HasMyTree_Dormant(false) && (cell.m_tree.m_size != MAX_TREE_SIZE && cell.m_tree.m_size != 0)){if (curCell == nullptr|| curCell->m_tree.m_size < cell.m_tree.m_size|| (curCell->m_tree.m_size == cell.m_tree.m_size && curCell->m_richness < cell.m_richness)){curCell = &cell;}}}if (curCell == nullptr || GetMySun() < GetUpgradePrice(curCell->m_tree.m_size)){return SCommand();}return CreateGrowCmd(curCell->m_index);}}
#include <random>
#include <time.h>
unsigned int UpdateRandomSeed(){unsigned int const seed = (unsigned int)time(nullptr);srand(seed);return seed;}unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal){assert(minVal < maxVal);unsigned int const range = maxVal - minVal;return rand() % range + minVal;}
using namespace std;CTimeProfiler::CTimeProfiler(char const* const name): m_name(name), m_startTime(chrono::high_resolution_clock::now()){}CTimeProfiler::~CTimeProfiler(){auto const end = chrono::high_resolution_clock::now();double const executionTime = (double)chrono::duration_cast<chrono::nanoseconds>(end - m_startTime).count();cerr.precision(3);cerr << m_name << ": " << executionTime / 1000000.0 << fixed << " ms" << endl;}
